<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinh tử môn</title>

    <link rel="stylesheet" href="/css/style.css">
    <!-- <script src="https://cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script> -->

    <script src="/js/mazePuzzle.js"></script>
    <script src="/js/tower.js"></script>
    <script src="/js/square.js"></script>
</head>

<body>

    <script>

        var mazePuzzle;

        var graphics;
        var towers = []

        var tempTower;

        var sampleTower1;
        var sampleTower2;
        var sampleTower3;
        var sampleTower4;

        var bullets = []
        var follower = null;
        var isBuying = false;
        var monsterVecs = []
        var lifeText;

        var COLLISION = [
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1]
        ];

        var START_POS = [0, 0];
        var END_POS = [13, 12];


        var OFFSET_Y = 100;
        var OFFSET_RIGHT_X = 180;
        var OFFSET_DOWN_Y = 30;
        var GAME_WIDTH = 520;
        var GAME_HEIGHT = 520;
        var CELL_SIZE = 40;


        var monsters = [];
        var pathOfMonsters = []

        var gold = null;
        var goldText = null;

        var config = {
            type: Phaser.AUTO,
            width: 700,
            height: 650,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: true,

                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var game = new Phaser.Game(config);

        function preload() {
            this.load.image('square', '/img/square1.png');
            this.load.image('bigBee', '/img/bigBee.png');
            this.load.image('frozen', '/img/frozen.png');
            this.load.image('arrow', '/img/arrow.png');

            this.load.image('upgrade', '/img/loop.png');
            this.load.spritesheet('sell', '/img/coin.png', { frameWidth: 32, frameHeight: 32 });

            this.load.image('power0', '/img/tower/power/0.png');
            this.load.image('power1', '/img/tower/power/1.png');
            this.load.image('power2', '/img/tower/power/2.png');
            this.load.image('power3', '/img/tower/power/3.png');
            this.load.image('power4', '/img/tower/power/4.png');
            this.load.image('power5', '/img/tower/power/5.png');

            wave = {
                id: 1,
                quantity: 1
            };

            life = 100;
            // gold = 250;
            gold = 10000;

            graphics = this.add.graphics();

            mazePuzzle = findWay(COLLISION, START_POS, END_POS);
            // console.log(mazePuzzle)
        }

        function create() {

            for (let i = 0; i < GAME_HEIGHT / CELL_SIZE; i++) {
                for (let j = 0; j < GAME_WIDTH / CELL_SIZE; j++) {
                    if (!COLLISION[i][j]) {
                        let square = new Square(this, j, i)
                    }
                }
            }

            this.anims.create({
                key: 'rotate',
                frames: 'sell',
                frameRate: 10,
                repeat: -1
            });

            this.add.text(1, 60, 'Cửa vào', { fontSize: '15px', fill: '#aaa' });
            this.add.text(445, 605, 'Cửa ra', { fontSize: '20px', fill: '#aaa' });
            this.add.text(300, 50, `Đợt ${wave.id}`, { fontSize: '20px', fill: '#aaa' });

            lifeText = this.add.text(300, 150, `Máu ${life}`, { fontSize: '20px', fill: '#aaa' });
            goldText = this.add.text(560, 180, `Vàng: ${gold}`, { fontSize: '20px', fill: '#aaa' });


            // tháp mẫu
            this.add.text(560, 200, 'Tháp', { fontSize: '20px', fill: '#aaa' });
            this.add.text(560, 420, 'Skill', { fontSize: '20px', fill: '#aaa' });

            sampleTower1 = new Tower(this, 580, 300, 'power0')

            // this.add.image(580, 300, `0.png`).setDisplaySize(40, 40)
            // this.add.image(580, 350, "arrow").setDisplaySize(40, 40);
            // this.add.image(640, 250, "frozen").setDisplaySize(40, 40);
            // this.add.image(640, 300, "frozen").setDisplaySize(40, 40);
            // this.add.image(640, 350, "frozen").setDisplaySize(40, 40);


            //Wave
            // let monsterRespawnEvent = this.time.addEvent({ delay: 10000, callback: () => monsterRespawn.call(this, 15), callbackScope: this, loop: true });
            monsterRespawn.call(this, 15)

            //is buying
            this.input.on("pointermove", (pointer) => {
                if (isBuying) {
                    // console.log("buying mouse move")
                    tempTower.x = pointer.x
                    tempTower.y = pointer.y
                }
            })

            // Huỷ chọn mua tháp khi click ra ngoài
            this.input.on("pointerdown", (pointer) => {
                if (
                    isBuying
                    &&
                    pointer.y > GAME_HEIGHT + OFFSET_Y
                ) {
                    console.log("clicked everywhere")
                    isBuying = false;
                    tempTower.destroy();
                }
            })
        }
        function monsterReachEndpoint(tween, target, sprite) {
            life -= 1;
            lifeText.setText(`Máu: ${life}`)
        }

        function monsterRespawn(number) {
            let monsterType = ["flying", "landing"];

            for (let i = 0; i < number; i++) {
                this.time.addEvent({
                    delay: i * 650, callback: () => {

                        let monster = this.physics.add.image(20, OFFSET_Y, "bigBee");

                        //monster body shape for collision
                        monster.setInteractive(new Phaser.Geom.Polygon([
                            50, 560,
                            550, 560,
                            550, 100,
                            900, 100,
                            900, 1050,
                            50, 1050,
                            50, 560
                        ]), Phaser.Geom.Polygon.Contains);

                        monster.setDisplaySize(40, 40);
                        monster.setDepth(0)
                        monster.type = "landing"
                        monster.speed = 100
                        monster.maxHealth = 1000
                        monster.health = 800

                        if (monster.type == "flying") {
                            monster.setVelocity(80, 80)
                            pathOfMonsters.push([])
                            monsterVecs.push(null)
                        }

                        if (monster.type == "landing") {
                            let path = new Phaser.Curves.Path(monster.x, monster.y);

                            mazePuzzle.forEach(i => {
                                path.lineTo(CELL_SIZE * i[1] + CELL_SIZE / 2, i[0] * CELL_SIZE + OFFSET_Y)
                            })
                            // console.log(path.getLength())
                            pathOfMonsters.push(path);
                            let duration = (Math.sqrt(path.getLength() * path.getLength()) / monster.speed) * 1000;
                            let follower = { t: 0, vec: new Phaser.Math.Vector2() };
                            let tween = this.tweens.add({
                                targets: follower,
                                t: 1,
                                ease: 'start',
                                duration: duration, // change
                                yoyo: false,
                                repeat: -2,
                                onComplete: monsterReachEndpoint,
                            });


                            monsterVecs.push(follower)
                        }

                        this.input.enableDebug(monster, 0xff00ff);


                        monsters.push(monster)
                    }, callbackScope: this, loop: false
                });
            }

        }

        function dealDamage(bullet, monster) {
            console.log("touch monster")
            bullets.splice(bullets.indexOf(bullet), 1)
            bullet.destroy();
        }

        function getDistance(objectA, objectB) {
            return Math.sqrt(
                (objectA.x - objectB.x) * (objectA.x - objectB.x)
                +
                (objectA.y - objectB.y) * (objectA.y - objectB.y)
            )
        }

        function shoot(monsters, towers) {
            //shoot
            towers.forEach(tower => {
                let minDistance = tower.range

                monsters.forEach(monster => {
                    let dist = getDistance(tower, monster)
                    if (
                        tower.isReady //sẵn sàng bắn // chờ nạp đạn
                        && minDistance > dist
                    ) {
                        minDistance = dist
                        tower.target = monster
                    }
                })

                if (minDistance < tower.range) {
                    //nạp đạn
                    tower.setTint("0xff00")
                    // tower.setAlpha(0.5)
                    tower.isReady = false;
                    this.time.addEvent({
                        delay: 2000, callback: () => {
                            tower.clearTint()
                            tower.isReady = true;
                        }, callbackScope: this, loop: false
                    });

                    //Tạo đạn và bắn

                    let bullet = this.physics.add.image(tower.x, tower.y, 'bullet');
                    bullet.setInteractive(new Phaser.Geom.Circle(
                        512, 512, 512
                    ), Phaser.Geom.Circle.Contains);
                    bullet.setTint("0xffffff")
                    bullet.setDisplaySize(30, 30);
                    bullet.speed = 200
                    bullet.setDepth(1)
                    //Giảm range của collider
                    bullet.target = tower.target
                    bullet.setCircle(45)
                    this.physics.add.overlap(bullet, bullet.target, dealDamage, null, this);

                    // this.input.enableDebug(bullet, 0xff00ff);
                    bullets.push(bullet)
                }

                else {
                    tower.setDisplaySize(40, 40)
                }
            })
        }

        function moveTo(source, target, speed) {
            //use linearInterpolation instead

            let angle = Math.atan2(Math.abs(target.x - source.x), Math.abs(target.y - source.y));

            if (target.x > source.x) {
                source.setVelocityX(speed * Math.sin(angle))
            }
            else {
                source.setVelocityX(-1 * speed * Math.sin(angle))
            }

            if (target.y > source.y) {
                source.setVelocityY(speed * Math.cos(angle))
            }
            else {
                source.setVelocityY(-1 * speed * Math.cos(angle))
            }

        }

        function update(time, delta) {

            graphics.clear();

            //end game
            if (life < 1) {
                this.physics.pause();
                return
            }



            //landing monster move
            monsters.forEach((monster, index) => {
                graphics.lineStyle(2, 0xffffff, 1);
                if (monster.type == "landing") {

                    graphics.lineStyle(2, 0xffffff, 1);

                    pathOfMonsters[index].draw(graphics);
                    // console.log(monsterVecs[index].t)

                    pathOfMonsters[index].getPoint(monsterVecs[index].t, monsterVecs[index].vec);
                    monster.setPosition(monsterVecs[index].vec.x, monsterVecs[index].vec.y)

                    // health draw
                    graphics.lineStyle(2, 0xff00, 0.5);
                    graphics.strokeRoundedRect(monster.x - monster.body.width / 2, monster.y + CELL_SIZE / 2, monster.body.width, CELL_SIZE / 7, 0);
                    graphics.fillStyle(0x00ff00, 1);
                    graphics.fillRect(monster.x - monster.body.width / 2, monster.y + CELL_SIZE / 2, monster.body.width * monster.health / monster.maxHealth, CELL_SIZE / 7);
                    //end health draw

                }

            })



            //Cập nhật đường đạn
            bullets.forEach(bullet => moveTo.call(this, bullet, bullet.target, bullet.speed));


            //fire
            shoot.call(this, monsters, towers)

        }
    </script>
</body>

</html>