<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinh tử môn</title>

    <link rel="stylesheet" href="/css/style.css">
    <!-- <script src="https://cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script> -->

    <script src="/js/mazePuzzle.js"></script>
</head>

<body>

    <script>

        var mazePuzzle;

        var graphics;
        var towers = []

        var tower1; //test
        var temp;


        var bullets = []
        var follower = null;
        var isBuying = false;
        var monsterVecs = []
        var lifeText;

        var COLLISION = [
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1]
        ];

        var START_POS = [0, 0];
        var END_POS = [13, 12];


        var OFFSET_Y = 100;
        var OFFSET_RIGHT_X = 180;
        var OFFSET_DOWN_Y = 30;
        var GAME_WIDTH = 520;
        var GAME_HEIGHT = 520;
        var CELL_SIZE = 40;


        var monsters = [];
        var pathOfMonsters = []

        var gold = null;
        var tower = null;

        var goldText = null;

        var config = {
            type: Phaser.AUTO,
            width: 700,
            height: 650,
            physics: {
                default: 'arcade',
                arcade: {
                    debug: true,

                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var game = new Phaser.Game(config);

        function preload() {
            this.load.image('square', '/img/square1.png');
            this.load.image('bigBee', '/img/bigBee.png');
            this.load.image('frozen', '/img/frozen.png');
            this.load.image('arrow', '/img/arrow.png');
            this.load.image('bullet', '/img/bullet.png');

            wave = {
                id: 1,
                quantity: 1
            };

            life = 10;
            // gold = 250;
            gold = 10000;

            graphics = this.add.graphics();

            mazePuzzle = findWay(COLLISION, START_POS, END_POS);
            // console.log(mazePuzzle)
        }

        function create() {
            // init square
            for (let i = 0; i < GAME_HEIGHT / CELL_SIZE; i++) {
                for (let j = 0; j < GAME_WIDTH / CELL_SIZE; j++) {
                    if (!COLLISION[i][j]) {
                        let square =
                            this.add.image(
                                j * CELL_SIZE + 20,
                                i * CELL_SIZE + OFFSET_Y,
                                "square"
                            ).setDisplaySize(40, 45);

                        square.posX = j
                        square.posY = i
                         
                        //decide buy
                        square.setInteractive()
                        square.on("pointerdown", (pointer) => {
                            console.log("clicked square")
                            if (isBuying && gold >= 70) {
                                //Check isOkPath
                                // pathOfMonsters.forEach()

                                //if
                                    //Kiểm tra xây được không


                                    //Cập nhật lại đường đi quái vật landing
                                //end if
                               
                                let tower = this.add.image(square.x, square.y, "arrow");
                                // console.log(square.x, square.y)
                                tower.setDisplaySize(40, 40)
                                tower.setDepth(-1)
                                tower.isReady = true;
                                tower.range = 80
                                tower.price = 70

                                gold -= tower.price
                                goldText.setText(`Vàng: ${gold}`)
                                // square.disableBody(true, true);
                                towers.push(tower)
                            }
                        })

                    }
                }

            }

            //end square

            this.add.text(1, 60, 'Cửa vào', { fontSize: '15px', fill: '#aaa' });
            this.add.text(445, 605, 'Cửa ra', { fontSize: '20px', fill: '#aaa' });
            this.add.text(300, 50, `Đợt ${wave.id}`, { fontSize: '20px', fill: '#aaa' });
            lifeText = this.add.text(300, 150, `Máu ${life}`, { fontSize: '20px', fill: '#aaa' });

            goldText = this.add.text(560, 180, `Vàng: ${gold}`, { fontSize: '20px', fill: '#aaa' });


            // tháp mẫu
            this.add.text(560, 200, 'Tháp', { fontSize: '20px', fill: '#aaa' });
            this.add.text(560, 420, 'Skill', { fontSize: '20px', fill: '#aaa' });


            tower1 = this.add.image(580, 250, "arrow").setDisplaySize(40, 40);
            tower1.price = 70
            tower1.setInteractive();
            this.add.image(580, 300, "arrow").setDisplaySize(40, 40);
            this.add.image(580, 350, "arrow").setDisplaySize(40, 40);
            this.add.image(640, 250, "frozen").setDisplaySize(40, 40);
            this.add.image(640, 300, "frozen").setDisplaySize(40, 40);
            this.add.image(640, 350, "frozen").setDisplaySize(40, 40);

            tower1.on("pointerdown", (pointer) => {
                //tạo tháp từ con trỏ chuột
                if (gold >= tower1.price) {
                    if (isBuying) {
                        temp.destroy();
                    }
                    isBuying = true;
                    temp = this.physics.add.image(pointer.x, pointer.y, "arrow");
                    temp.setDisplaySize(40, 40)
                    temp.setAlpha(0.5)
                    
                }
            })

            //Wave
            // let monsterRespawnEvent = this.time.addEvent({ delay: 10000, callback: () => monsterRespawn.call(this, 15), callbackScope: this, loop: true });
            monsterRespawn.call(this, 15)
        }
        function monsterReachEndpoint(tween, target, sprite) {
            life -= 1;
            lifeText.setText(`Máu: ${life}`)
        }

        function monsterRespawn(number) {
            let monsterType = ["flying", "landing"];

            for (let i = 0; i < number; i++) {
                this.time.addEvent({
                    delay: i * 650, callback: () => {

                        let monster = this.physics.add.image(20, OFFSET_Y, "bigBee");

                        //monster body shape for collision
                        monster.setInteractive(new Phaser.Geom.Polygon([
                            50, 560,
                            550, 560,
                            550, 100,
                            900, 100,
                            900, 1050,
                            50, 1050,
                            50, 560
                        ]), Phaser.Geom.Polygon.Contains);

                        monster.setDisplaySize(40, 40);
                        monster.setDepth(0)
                        monster.type = "landing"
                        monster.speed = 100
                        monster.maxHealth = 1000
                        monster.health = 800

                        if (monster.type == "flying") {
                            monster.setVelocity(80, 80)
                            pathOfMonsters.push([])
                            monsterVecs.push(null)
                        }

                        if (monster.type == "landing") {
                            let path = new Phaser.Curves.Path(monster.x, monster.y);

                            mazePuzzle.forEach(i => {
                                path.lineTo(CELL_SIZE * i[1] + CELL_SIZE / 2, i[0] * CELL_SIZE + OFFSET_Y)
                            })
                            // console.log(path.getLength())
                            pathOfMonsters.push(path);
                            let duration = (Math.sqrt(path.getLength() * path.getLength()) / monster.speed) * 1000;
                            let follower = { t: 0, vec: new Phaser.Math.Vector2() };
                            let tween = this.tweens.add({
                                targets: follower,
                                t: 1,
                                ease: 'start',
                                duration: duration, // change
                                yoyo: false,
                                repeat: -2,
                                onComplete: monsterReachEndpoint,
                            });


                            monsterVecs.push(follower)
                        }

                        this.input.enableDebug(monster, 0xff00ff);


                        monsters.push(monster)
                    }, callbackScope: this, loop: false
                });
            }

        }

        function dealDamage(bullet, monster) {
            console.log("touch monster")
            bullets.splice(bullets.indexOf(bullet), 1)
            bullet.destroy();
        }

        function getDistance(objectA, objectB) {
            return Math.sqrt(
                (objectA.x - objectB.x) * (objectA.x - objectB.x)
                +
                (objectA.y - objectB.y) * (objectA.y - objectB.y)
            )
        }

        function shoot(monsters, towers) {
            //shoot
            towers.forEach(tower => {
                let minDistance = tower.range

                monsters.forEach(monster => {
                    let dist = getDistance(tower, monster)
                    if (
                        tower.isReady //sẵn sàng bắn // chờ nạp đạn
                        && minDistance > dist
                    ) {
                        minDistance = dist
                        tower.target = monster
                    }
                })

                if (minDistance < tower.range) {
                    //nạp đạn
                    tower.setTint("0xff00")
                    // tower.setAlpha(0.5)
                    tower.isReady = false;
                    this.time.addEvent({
                        delay: 2000, callback: () => {
                            tower.clearTint()
                            tower.isReady = true;
                        }, callbackScope: this, loop: false
                    });

                    //Tạo đạn và bắn

                    let bullet = this.physics.add.image(tower.x, tower.y, 'bullet');
                    bullet.setInteractive(new Phaser.Geom.Circle(
                        512, 512, 512
                    ), Phaser.Geom.Circle.Contains);
                    bullet.setTint("0xffffff")
                    bullet.setDisplaySize(30, 30);
                    bullet.speed = 200
                    bullet.setDepth(1)
                    //Giảm range của collider
                    bullet.target = tower.target
                    bullet.setCircle(45)
                    this.physics.add.overlap(bullet, monsters[0], dealDamage, null, this);

                    // this.input.enableDebug(bullet, 0xff00ff);
                    bullets.push(bullet)
                }

                else {
                    tower.setDisplaySize(40, 40)
                }
            })
        }

        function moveTo(source, target, speed) {
            //use linearInterpolation instead


            let angle = Math.atan2(Math.abs(target.x - source.x), Math.abs(target.y - source.y));

            if (target.x > source.x) {
                source.setVelocityX(speed * Math.sin(angle))
            }
            else {
                source.setVelocityX(-1 * speed * Math.sin(angle))
            }

            if (target.y > source.y) {
                source.setVelocityY(speed * Math.cos(angle))
            }
            else {
                source.setVelocityY(-1 * speed * Math.cos(angle))
            }

        }

        function update(time, delta) {

            graphics.clear();

            //end game
            if (life < 1) {
                this.physics.pause();
                return
            }


            //landing monster move
            monsters.forEach((monster, index) => {
                graphics.lineStyle(2, 0xffffff, 1);
                if (monster.type == "landing") {

                    graphics.lineStyle(2, 0xffffff, 1);

                    pathOfMonsters[index].draw(graphics);
                    // console.log(monsterVecs[index].t)

                    pathOfMonsters[index].getPoint(monsterVecs[index].t, monsterVecs[index].vec);
                    monster.setPosition(monsterVecs[index].vec.x, monsterVecs[index].vec.y)

                    // health draw
                    graphics.lineStyle(2, 0xff00, 0.5);
                    graphics.strokeRoundedRect(monster.x - monster.body.width / 2, monster.y + CELL_SIZE / 2, monster.body.width, CELL_SIZE / 7, 0);
                    graphics.fillStyle(0x00ff00, 1);
                    graphics.fillRect(monster.x - monster.body.width / 2, monster.y + CELL_SIZE / 2, monster.body.width * monster.health / monster.maxHealth, CELL_SIZE / 7);
                    //end health draw

                }

            })

            //is buying
            if (isBuying) {
                this.input.on("pointermove", (pointer) => {
                    temp.x = pointer.x
                    temp.y = pointer.y
                })
            }

            // Huỷ chọn mua tháp khi click ra ngoài
            this.input.on("pointerdown", (pointer) => {
                if (isBuying
                    && pointer.y > GAME_HEIGHT + OFFSET_Y
                    && pointer.y > OFFSET_Y + GAME_HEIGHT
                ) {
                    console.log("clicked everywhere")
                    isBuying = false;
                    temp.destroy();
                }
            })

            //Cập nhật đường đạn
            bullets.forEach(bullet => moveTo.call(this, bullet, bullet.target, bullet.speed));


            //fire
            shoot.call(this, monsters, towers)

        }
    </script>
</body>

</html>